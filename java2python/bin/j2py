#!/usr/bin/env python
# -*- coding: utf-8 -*-
import compiler
import logging
import optparse
import os.path
import sys
from collections import defaultdict
from time import time

from antlr3 import ANTLRStringStream
from antlr3.tree import CommonTreeNodeStream

from java2python.parser.helpers import LocalTokenStream
from java2python.parser.JavaParser import JavaParser
from java2python.parser.JavaLexer import JavaLexer
from java2python.parser.JavaTreeParser import JavaTreeParser
from java2python.sourcetypes import Module

try:
    import psyco
except (ImportError, ):
    pass
else:
    psyco.full()


def bad_loglevel(name, value):
    msg = 'option %s: invalid loglevel: %r'
    raise optparse.OptionValueError(msg % (name, value))


def check_loglevel(option, opt, value):
    try:
        lvl = int(value)
    except (ValueError, ):
        name = value.upper()
        if name not in logging._levelNames:
            bad_loglevel(opt, value)
        lvl = logging._levelNames[name]
    else:
        if lvl not in logging._levelNames:
            bad_loglevel(opt, value)
    return lvl


class LocalOption(optparse.Option):
    TYPES = optparse.Option.TYPES + ('loglevel', )
    TYPE_CHECKER = optparse.Option.TYPE_CHECKER.copy()
    TYPE_CHECKER['loglevel'] = check_loglevel


def transform(options):
    timed = defaultdict(time)
    timed['overall']

    source = open(options.inputfile).read()
    stream = ANTLRStringStream(source)
    lexer = JavaLexer(stream)
    tokens = LocalTokenStream(lexer)
    parser = JavaParser(tokens)

    timed['comp']
    try:
	root = parser.javaSource().tree
    except (Exception, ), exc:
        logging.exception('exception while parsing')
        return 1
    timed['comp_finish']

    timed['ast']
    nodes = CommonTreeNodeStream(root)
    nodes.setTokenStream(tokens)
    walker = JavaTreeParser(nodes)
    timed['ast_finish']
#    if not ast:
#       print '*** error: no AST generated.'
#       return 2

    filein = fileout = filedefault = '-'
    if options.inputfile:
	filein = os.path.basename(options.inputfile)
    if options.outputfile:
	fileout = os.path.basename(options.outputfile)
    elif fileout != filedefault:
	fileout = '%s.py' % (os.path.splitext(filein)[0])

    if fileout == filedefault:
	output = sys.stdout
    else:
	output = open(fileout, 'w')

    configs = options.configs
    if options.includedefaults:
        configs.insert(0, 'java2python.config.default')
    Module.setConfigs(configs)
    mod = Module(filein, fileout)

    timed['walk']
    walker.javaSource(mod)
    source = mod.asString()
    print >> output, source
    timed['walk_finish']

    try:
        compiler.parse(source)
    except (SyntaxError, ), ex:
        logging.warning('Generated source has invalid syntax.')
    else:
        logging.info('Generated source has valid syntax.')

    timed['overall_finish']
    info, ts = logging.info, timed
    info('Parser comp unit time: %.4f', ts['comp_finish'] - ts['comp'])
    info('AST get time: %.4f', ts['ast_finish'] - ts['ast'])
    info('Walk and generate time: %.4f', ts['walk_finish'] - ts['walk'])
    info('Total time: %.4f', ts['overall_finish'] - ts['overall'])
    return 0


def cli_options(argv):
    parser = optparse.OptionParser(option_class=LocalOption, version='%prog 0.3')
    parser.add_option('-i', '--input', dest='inputfile',
		      help='read INPUTFILE',
		      metavar='INPUTFILE', default=None)
    parser.add_option('-o', '--output', dest='outputfile',
		      help='write OUTPUTFILE',
		      metavar='OUTPUTFILE', default=None)
    parser.add_option('-c', '--config', dest='configs',
		      help='use CONFIG (multiple allowed)',
		      metavar='CONFIG', default=[],
		      action='append')
    parser.add_option('-n', '--nodefaults', dest='includedefaults',
		      help='ignore default configuration',
		      default=True, action='store_false')
    parser.add_option('-l', '--loglevel', dest='loglevel',
		      help='Set log level by name or value',
		      default='INFO', type='loglevel')
    options, args = parser.parse_args(argv)
    if len(args) > 2:
	parser.error('Only one input file supported.')
    elif len(args) == 2:
	options.inputfile = args[1]
    return options, args

if __name__ == '__main__':
    options, args = cli_options(sys.argv)
    fmt = '# %(levelname)s %(funcName)s: %(message)s'
    logging.basicConfig(level=options.loglevel, format=fmt)
    ret = transform(options)
    sys.exit(ret)
